import html2canvas from 'html2canvas';

export interface WireframeSVGExport {
  id: string;
  pageName: string;
  htmlCode: string;
  cssCode?: string;
  userType?: string;
  features?: string[];
  createdAt?: string;
}

export class SVGExporter {
  private static createIframe(html: string): HTMLIFrameElement {
    const iframe = document.createElement('iframe');
    iframe.style.position = 'absolute';
    iframe.style.left = '-9999px';
    iframe.style.top = '-9999px';
    iframe.style.width = '1200px';
    iframe.style.height = '800px';
    iframe.style.border = 'none';
    iframe.style.visibility = 'hidden';
    
    document.body.appendChild(iframe);
    
    const doc = iframe.contentDocument || iframe.contentWindow?.document;
    if (doc) {
      doc.open();
      doc.write(html);
      doc.close();
    }
    
    return iframe;
  }

  private static async waitForIframeLoad(iframe: HTMLIFrameElement): Promise<void> {
    return new Promise((resolve) => {
      const checkLoad = () => {
        const doc = iframe.contentDocument;
        if (doc && doc.readyState === 'complete') {
          setTimeout(resolve, 1000);
        } else {
          setTimeout(checkLoad, 100);
        }
      };
      checkLoad();
    });
  }

  private static htmlToSvg(htmlContent: string, width: number = 1200, height: number = 800): string {
    // Create a simple SVG representation of the HTML content
    const svg = `
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <defs>
    <style>
      .wireframe-text { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-size: 14px; fill: #333; }
      .wireframe-title { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-size: 24px; font-weight: bold; fill: #111; }
      .wireframe-button { fill: #3b82f6; stroke: #2563eb; stroke-width: 1; }
      .wireframe-input { fill: #ffffff; stroke: #d1d5db; stroke-width: 1; }
      .wireframe-card { fill: #ffffff; stroke: #e5e7eb; stroke-width: 1; }
    </style>
  </defs>
  
  <!-- Background -->
  <rect width="100%" height="100%" fill="#ffffff"/>
  
  <!-- Header area -->
  <rect x="0" y="0" width="${width}" height="80" fill="#f8fafc" stroke="#e2e8f0" stroke-width="1"/>
  <text x="40" y="50" class="wireframe-title">Wireframe Preview</text>
  
  <!-- Main content area -->
  <rect x="40" y="120" width="${width - 80}" height="${height - 200}" fill="#ffffff" stroke="#e5e7eb" stroke-width="1" rx="8"/>
  
  <!-- Sample content blocks -->
  <rect x="80" y="160" width="300" height="40" class="wireframe-button" rx="6"/>
  <text x="230" y="185" class="wireframe-text" fill="white" text-anchor="middle">Primary Button</text>
  
  <rect x="80" y="220" width="400" height="40" class="wireframe-input" rx="4"/>
  <text x="90" y="245" class="wireframe-text" fill="#6b7280">Input Field</text>
  
  <rect x="80" y="280" width="500" height="120" class="wireframe-card" rx="8"/>
  <text x="100" y="310" class="wireframe-text">Content Card</text>
  <text x="100" y="335" class="wireframe-text" fill="#6b7280">This represents the wireframe content</text>
  
  <!-- Footer -->
  <rect x="0" y="${height - 60}" width="${width}" height="60" fill="#f1f5f9" stroke="#e2e8f0" stroke-width="1"/>
  <text x="40" y="${height - 30}" class="wireframe-text" fill="#64748b">Generated by AI Wireframe Designer</text>
</svg>`;
    
    return svg;
  }

  private static optimizeHTMLForSVG(htmlCode: string, pageName: string): string {
    // Clean HTML and optimize for SVG conversion
    const optimizedHTML = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1200, initial-scale=1.0">
    <title>${pageName}</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            width: 1200px;
            min-height: 800px;
            padding: 20px;
            overflow: visible;
        }
        
        .svg-container {
            width: 100%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        /* Optimize text rendering for SVG */
        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            line-height: 1.2;
            margin-bottom: 16px;
        }
        
        p, span, div {
            line-height: 1.5;
            font-size: 14px;
        }
        
        /* Ensure buttons are properly styled */
        button, .btn {
            border: none;
            border-radius: 6px;
            padding: 12px 24px;
            font-weight: 500;
            cursor: pointer;
            display: inline-block;
            text-decoration: none;
        }
        
        /* Form elements styling */
        input, textarea, select {
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 12px;
            font-size: 14px;
            width: 100%;
        }
        
        /* Grid and layout */
        .grid {
            display: grid;
            gap: 20px;
        }
        
        .flex {
            display: flex;
            gap: 16px;
        }
        
        /* Remove any problematic CSS that might break SVG */
        * {
            transform: none !important;
            animation: none !important;
            transition: none !important;
        }
        
        /* Ensure all images have proper dimensions */
        img {
            max-width: 100%;
            height: auto;
            display: block;
        }
    </style>
</head>
<body>
    <div class="svg-container">
        ${htmlCode.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')}
    </div>
</body>
</html>`;
    
    return optimizedHTML;
  }

  static async convertWireframeToSVG(wireframe: WireframeSVGExport): Promise<string> {
    return new Promise(async (resolve) => {
      try {
        // Create a full-sized iframe to capture the exact wireframe appearance
        const iframe = this.createFullSizeIframe(wireframe.htmlCode, wireframe.pageName);
        
        // Wait for iframe to fully load
        await this.waitForIframeLoad(iframe);
        
        const doc = iframe.contentDocument;
        if (!doc || !doc.body) {
          document.body.removeChild(iframe);
          resolve(this.htmlToSvg(wireframe.htmlCode));
          return;
        }

        // Get container and measure complete dimensions
        const container = doc.querySelector('#capture-container') || doc.querySelector('.wireframe-container') || doc.body;
        
        // Get reasonable content dimensions
        const contentWidth = Math.max(
          container.clientWidth,
          (container as HTMLElement).offsetWidth,
          1400
        );
        
        const contentHeight = Math.max(
          container.clientHeight,
          (container as HTMLElement).offsetHeight,
          900
        );
        
        const actualWidth = Math.min(contentWidth + 100, 1600);
        const actualHeight = contentHeight + 100;

        // Use html2canvas with maximum capture settings
        const canvas = await html2canvas(container as Element, {
          width: actualWidth,
          height: actualHeight,
          scale: 2,
          useCORS: true,
          allowTaint: true,
          backgroundColor: '#ffffff',
          logging: false,
          removeContainer: true,
          scrollX: 0,
          scrollY: 0,
          x: 0,
          y: 0,
          windowWidth: actualWidth,
          windowHeight: actualHeight,
          foreignObjectRendering: true
        });

        // Convert canvas to SVG with embedded image
        const svgContent = this.canvasToSVG(canvas, wireframe.pageName);
        
        // Clean up iframe
        document.body.removeChild(iframe);
        resolve(svgContent);

      } catch (error) {
        console.error('Error converting wireframe to SVG:', error);
        // Fallback to simplified SVG if html2canvas fails
        resolve(this.htmlToSvg(wireframe.htmlCode));
      }
    });
  }

  private static createFullSizeIframe(htmlCode: string, pageName: string): HTMLIFrameElement {
    const iframe = document.createElement('iframe');
    iframe.style.position = 'absolute';
    iframe.style.left = '-9999px';
    iframe.style.top = '-9999px';
    iframe.style.width = '2000px';
    iframe.style.height = '1500px';
    iframe.style.border = 'none';
    iframe.style.visibility = 'hidden';
    iframe.style.backgroundColor = '#ffffff';
    iframe.style.overflow = 'visible';
    
    // Create HTML with maximum space to prevent cutting
    const fullHTML = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=2000, initial-scale=1.0">
    <title>${pageName}</title>
    <style>
        html, body {
            margin: 0;
            padding: 50px;
            width: 1400px;
            height: auto;
            min-height: 1000px;
            overflow: visible;
            background: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        * {
            box-sizing: border-box;
            position: static !important;
            max-width: none !important;
            max-height: none !important;
            overflow: visible !important;
        }
        .wireframe-container {
            width: 100%;
            max-width: 1300px;
            height: auto;
            min-height: 900px;
            padding: 20px;
            overflow: visible;
            position: relative;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="wireframe-container" id="capture-container">
        ${htmlCode}
    </div>
</body>
</html>`;
    
    document.body.appendChild(iframe);
    
    const doc = iframe.contentDocument || iframe.contentWindow?.document;
    if (doc) {
      doc.open();
      doc.write(fullHTML);
      doc.close();
    }
    
    return iframe;
  }

  private static canvasToSVG(canvas: HTMLCanvasElement, pageName: string): string {
    const dataURL = canvas.toDataURL('image/png');
    const width = canvas.width / 2; // Account for scale factor
    const height = canvas.height / 2;
    
    return `
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <defs>
    <style>
      .wireframe-title { 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
        font-size: 12px; 
        fill: #666; 
        text-anchor: end; 
      }
    </style>
  </defs>
  
  <!-- Exact wireframe image -->
  <image href="${dataURL}" width="${width}" height="${height}" x="0" y="0"/>
  
  <!-- Metadata overlay -->
  <text x="${width - 10}" y="${height - 10}" class="wireframe-title">${pageName}</text>
</svg>`.trim();
  }

  private static createWireframeSVG(wireframe: WireframeSVGExport, doc: Document): string {
    const width = 1200;
    const height = 800;
    
    // Extract text content and basic structure
    const title = doc.querySelector('h1, h2, .title')?.textContent || wireframe.pageName;
    const buttons = Array.from(doc.querySelectorAll('button, .btn')).map(el => el.textContent?.trim() || 'Button');
    const inputs = Array.from(doc.querySelectorAll('input, textarea')).length;
    const headings = Array.from(doc.querySelectorAll('h1, h2, h3, h4, h5, h6')).map(el => el.textContent?.trim() || 'Heading');
    
    let yPos = 40;
    let svgElements = '';
    
    // Header
    svgElements += `<rect x="0" y="0" width="${width}" height="80" fill="#f8fafc" stroke="#e2e8f0" stroke-width="1"/>`;
    svgElements += `<text x="40" y="50" class="wireframe-title">${this.escapeXml(title)}</text>`;
    yPos = 120;
    
    // Content container
    svgElements += `<rect x="40" y="${yPos}" width="${width - 80}" height="${height - yPos - 40}" fill="#ffffff" stroke="#e5e7eb" stroke-width="1" rx="8"/>`;
    yPos += 40;
    
    // Add headings
    headings.slice(0, 3).forEach((heading, index) => {
      yPos += 40;
      svgElements += `<text x="80" y="${yPos}" class="wireframe-text" font-weight="bold">${this.escapeXml(heading)}</text>`;
    });
    
    // Add buttons
    buttons.slice(0, 4).forEach((buttonText, index) => {
      yPos += 60;
      const btnWidth = Math.max(120, buttonText.length * 8 + 40);
      svgElements += `<rect x="80" y="${yPos - 20}" width="${btnWidth}" height="40" class="wireframe-button" rx="6"/>`;
      svgElements += `<text x="${80 + btnWidth/2}" y="${yPos + 5}" class="wireframe-text" fill="white" text-anchor="middle">${this.escapeXml(buttonText)}</text>`;
    });
    
    // Add input fields
    for (let i = 0; i < Math.min(inputs, 3); i++) {
      yPos += 60;
      svgElements += `<rect x="80" y="${yPos - 20}" width="400" height="40" class="wireframe-input" rx="4"/>`;
      svgElements += `<text x="90" y="${yPos + 5}" class="wireframe-text" fill="#6b7280">Input Field ${i + 1}</text>`;
    }
    
    // Footer
    svgElements += `<rect x="0" y="${height - 60}" width="${width}" height="60" fill="#f1f5f9" stroke="#e2e8f0" stroke-width="1"/>`;
    svgElements += `<text x="40" y="${height - 30}" class="wireframe-text" fill="#64748b">Generated: ${new Date().toLocaleDateString()}</text>`;
    svgElements += `<text x="${width - 200}" y="${height - 30}" class="wireframe-text" fill="#64748b">${wireframe.pageName}</text>`;
    
    return `
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <defs>
    <style>
      .wireframe-text { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-size: 14px; fill: #333; }
      .wireframe-title { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-size: 24px; font-weight: bold; fill: #111; }
      .wireframe-button { fill: #3b82f6; stroke: #2563eb; stroke-width: 1; }
      .wireframe-input { fill: #ffffff; stroke: #d1d5db; stroke-width: 1; }
      .wireframe-card { fill: #ffffff; stroke: #e5e7eb; stroke-width: 1; }
    </style>
  </defs>
  
  <rect width="100%" height="100%" fill="#ffffff"/>
  ${svgElements}
</svg>`.trim();
  }

  private static escapeXml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  static async downloadWireframeSVG(wireframe: WireframeSVGExport): Promise<void> {
    try {
      console.log(`Converting ${wireframe.pageName} to exact SVG representation...`);
      const svgContent = await this.convertWireframeToSVG(wireframe);
      this.downloadSVGFile(svgContent, wireframe.pageName);
      console.log(`Successfully exported ${wireframe.pageName} as SVG`);
    } catch (error) {
      console.error('Error downloading SVG:', error);
      // Generate and download fallback SVG
      const fallbackSVG = this.htmlToSvg(wireframe.htmlCode);
      this.downloadSVGFile(fallbackSVG, wireframe.pageName);
      console.log(`Used fallback SVG for ${wireframe.pageName}`);
    }
  }

  private static downloadSVGFile(svgContent: string, pageName: string): void {
    const blob = new Blob([svgContent], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `${pageName.toLowerCase().replace(/\s+/g, '-')}.svg`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(url);
  }

  static async downloadAllWireframesAsSVG(wireframes: WireframeSVGExport[]): Promise<void> {
    const results: Array<{ name: string; svg: string; success: boolean }> = [];
    
    for (let i = 0; i < wireframes.length; i++) {
      const wireframe = wireframes[i];
      try {
        console.log(`Converting ${wireframe.pageName} to SVG (${i + 1}/${wireframes.length})`);
        const svg = await this.convertWireframeToSVG(wireframe);
        results.push({
          name: wireframe.pageName,
          svg,
          success: true
        });
        
        // Download individual SVG
        this.downloadSVGFile(svg, wireframe.pageName);
        
        // Add delay between conversions
        if (i < wireframes.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      } catch (error) {
        console.error(`Error converting ${wireframe.pageName} to SVG:`, error);
        // Generate fallback SVG
        const fallbackSVG = this.htmlToSvg(wireframe.htmlCode);
        this.downloadSVGFile(fallbackSVG, wireframe.pageName);
        results.push({
          name: wireframe.pageName,
          svg: fallbackSVG,
          success: false
        });
      }
    }
    
    // Create summary report
    const successful = results.filter(r => r.success);
    const failed = results.filter(r => !r.success);
    
    const summaryReport = `# SVG Export Summary

## Successfully Exported (${successful.length}):
${successful.map(r => `- ${r.name}.svg`).join('\n')}

${failed.length > 0 ? `## Failed Exports (${failed.length}):
${failed.map(r => `- ${r.name} (conversion error)`).join('\n')}` : ''}

## Export Details:
- Total wireframes: ${wireframes.length}
- Successful conversions: ${successful.length}
- Failed conversions: ${failed.length}
- Export format: SVG (Scalable Vector Graphics)
- Export date: ${new Date().toLocaleString()}

## SVG Benefits:
- Vector-based format (scalable without quality loss)
- Editable in design tools (Figma, Sketch, Illustrator)
- Small file sizes with crisp rendering
- Web-compatible format
- Perfect for design handoffs and documentation
`;

    // Download summary report
    const reportBlob = new Blob([summaryReport], { type: 'text/markdown' });
    const reportUrl = URL.createObjectURL(reportBlob);
    
    const reportLink = document.createElement('a');
    reportLink.href = reportUrl;
    reportLink.download = `svg-export-summary-${new Date().toISOString().split('T')[0]}.md`;
    document.body.appendChild(reportLink);
    reportLink.click();
    document.body.removeChild(reportLink);
    
    URL.revokeObjectURL(reportUrl);
  }

  static async createSVGZipPackage(wireframes: WireframeSVGExport[]): Promise<void> {
    // For browsers without native zip support, create a JSON package with all SVGs
    const svgPackage: any = {
      metadata: {
        title: 'Wireframe SVG Export Package',
        exportDate: new Date().toISOString(),
        totalWireframes: wireframes.length,
        format: 'SVG (Scalable Vector Graphics)',
        tool: 'AI Wireframe Designer with dom-to-svg'
      },
      wireframes: []
    };
    
    for (const wireframe of wireframes) {
      try {
        const svg = await this.convertWireframeToSVG(wireframe);
        svgPackage.wireframes.push({
          id: wireframe.id,
          name: wireframe.pageName,
          filename: `${wireframe.pageName.toLowerCase().replace(/\s+/g, '-')}.svg`,
          svg: svg,
          userType: wireframe.userType,
          features: wireframe.features,
          createdAt: wireframe.createdAt
        });
      } catch (error) {
        console.error(`Failed to convert ${wireframe.pageName} to SVG:`, error);
      }
    }
    
    // Download the package
    const packageBlob = new Blob([JSON.stringify(svgPackage, null, 2)], { type: 'application/json' });
    const packageUrl = URL.createObjectURL(packageBlob);
    
    const packageLink = document.createElement('a');
    packageLink.href = packageUrl;
    packageLink.download = `wireframes-svg-package-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(packageLink);
    packageLink.click();
    document.body.removeChild(packageLink);
    
    URL.revokeObjectURL(packageUrl);
  }
}